# Processo seletivo TrackCash
![enter image description here](data:image/png;base64,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)
O objetivo deste repositório é armazenar os códigos necessários para o processo seletivo da empresa TrackCash. Os três algoritmos consistem em:
- emailAutomation: extração de anexo de email usando o assunto como critério.
- seleniumExtraction: automação de rotina utilizando a biblioteca Selenium.
- spreadsheetAnalysis: análise de dados utilizando Pandas.

Observações: Para rodar os algoritmos é necessário que seja configurado as variáveis de ambiente nos arquivos assets/.env_email e assets/.env_selenium, além de rodar o comando "pip install -r requirements.txt" no terminal. Não consegui acessar o email passado atráves do host "TrackCash" então criei um email com as mesmas especificações no meu email pessoal, o resultado foi o mesmo caso tivesse sido usado o email passado.


## Explicação algoritmos

### emailAutomation

    import email
    import imaplib
    from dotenv import load_dotenv
    from os import environ,path,getcwd
    
   A biblioteca imaplib é utilizada para acessas o conteúdo da caixa de email através do host, a email é usada para converter o formato do e-mail de bytes para base64. A biblioteca dotenv é uma biblioteca para gerenciar variaveis de ambiente, a biblioteca os é utilizada para gerenciar os paths do projeto.

    envPath = path.join(getcwd(),'assets','.env_email')
    
    load_dotenv(envPath)
Variáveis globais usadas no projeto, basicamente carrega as variáveis de ambiente salvas no arquivo assets/.env_email.

    def connectOnEmail():
	    emailHost = environ.get("HOST")
	    mail = imaplib.IMAP4_SSL(emailHost)
	    mail.login(environ.get("EMAIL_USER"),environ.get("EMAIL_PASSWORD"))
    
	    return mail
        
   Função para se conectar no e-mail fornecido nas variáveis de ambiente, usando o host declarado no mesmo.

       def disconnectFromEmail(mail):
	       mail.close()
		   mail.logout()
		   
  Função que desconecta do e-mail passado como parâmetro.

    def getAttacheament(filename,content):
 
	    if filename != None and content != None:
	    
		    savePath = path.join(getcwd(),'assets','extraction',filename)
	    
	    with open(savePath,'wb') as emailAttacheament:
		   emailAttacheament.write(content.get_payload(decode=True))
		   emailAttacheament.close()
  Função para baixar e salvar o arquivo anexo do e-mail selecionado, recebe como parâmetro o nome do arquivo e o seu conteúdo.

    def searchMessage(mail,subject):
    
	    mail.select()
	    
	    typ,data = mail.search(None,'(SUBJECT "{subject}")'.format(subject=subject))
	    
	    if typ == 'OK':
	    
		    typ,data = mail.fetch(data[0],'(RFC822)')
			emaiBody = data[0][1]
			emailFromBytes = email.message_from_bytes(emaiBody)
		    
		    for part in emailFromBytes.walk():
		    
			    if part.get_content_maintype() == "multipart":
				    continue
	    
			    if part.get('Content-Disposition') is None:
				    continue
		    
			    filename = part.get_filename()
			    
			    return filename,part
		    
	    return [None,None]

Função para procurar um e-mail na caixa do usuário logado usando como critério o assunto, essa função retorna o a parte do e-mail que contém o anexo e também o nome do anexo.

    if __name__ == '__main__':
        mail = connectOnEmail()
    	filename,part = searchMessage(mail,"Planilha de Repasse")
        getAttacheament(filename,part)
        disconnectFromEmail(mail)
Função principal, utilizada para controlar toda a aplicação, no primeiro comando ele faz uma instancia de um cliente de e-mail já logado nas credenciais das variáveis de ambiente, logo depois ele chama a função de procurar e-mail utilizando o objeto de e-mail e o parâmetro de busca por assunto, seguindo para o terceiro comando ele baixa o anexo utilizando as variáveis extraídas da função anterior e em sequência desconecta do e-mail.

### spreadsheetAnalysis

    import pandas as pd
    from os import getcwd,path
A biblioteca pandas será utilizada para analisar os dados da planilha baixada no ultimo algoritmo já a biblioteca os continuará com a função de gerenciar os paths do projeto.

    def loadSpreadSheet(spreadsheetName):
    
	    spreadSheetPath = path.join(getcwd(),'assets','extraction',spreadsheetName)
	    
	    if path.exists(spreadSheetPath):
	    
		    spreadsheet = pd.read_excel(spreadSheetPath)
		    spreadsheet = spreadsheet.fillna(0.0)
		    
		    return spreadsheet
Essa função carregará a planilha para uma estrutura de DataFrame, além de tratar os dados para que todos os valores NaN sejam substituídos por 0, evitando possíveis erros nas operações.

    def processInfos(spreadsheet):
    
	    print("Linhas processadas:"+str(len(spreadsheet)))
	    print("Registros Conciliados:"+str(len(spreadsheet[spreadsheet["Conciliação*"] == "Conciliado"])))
	    print("Registros Não Conciliados:"+str(len(spreadsheet[spreadsheet["Conciliação*"] == "Não Conciliado"])))
	    print("Registros Retirados:"+str(len(spreadsheet[spreadsheet["Conciliação*"] == "Retirada"])))
	    print("Registros Movimentados:"+str(len(spreadsheet[spreadsheet["Conciliação*"] == "Movimentação"])))
	   
	    for column in ["Comissão ML por parcela","Valor bruto da parcela"]:
	    
		    if spreadsheet[column].dtypes == 'float64' or spreadsheet[column].dtype == 'int64':
			    sum = str(spreadsheet[column].sum())
			    print("Soma da coluna {column}:{sum}".format(column=column,sum=sum))
Essa função irá exibir alguns dados a respeito da planilha, como a soma de colunas numéricas utilizadas na visualização além de quantidade de dados.

    def compareMultiplicationWithInput(multiplicand,multiplicator,inputProduct):
    
	    if multiplicand * multiplicator == inputProduct:
		    return "Conciliado"
	    
	    return "Não Conciliado"
Função que será utilizado pela funções que serão mostradas a seguir para definir uma transação como "Conciliado" ou "Não Conciliado", de acordo com as regras de negócio passadas.

    def creditCardAndBillet(grossInstallmentAmount,commission,mlComissionPerInstallment):
    
	     return compareMultiplicationWithInput(grossInstallmentAmount,commission,mlComissionPerInstallment)
    
    def reversal(grossValueOrder,comission,liquidValueInstallament):
    
	    return compareMultiplicationWithInput(grossValueOrder,comission,liquidValueInstallament)
Em suma as duas funções executam a mesma operação, deixei elas separadas somente para facilitar a leitura e entendimento do código. A primeira função trata o caso específico de pagamento com cartão de crédito ou boleto e a segunda no caso de estorno.

    def transference(antecipationValue):
    
	    if antecipationValue>0:
		    return "Retirada"
	    
	    return "Movimentação"
Função para tratar o caso específico de transferência, classificando a conciliação como "Retirada" ou "Movimentada" de acordo com a regra de negócio.

    def specificCases(row):
    
	    conciliation = None
	    
	    if row["Método de pagamento"].lower() == "cartão de crédito" or row["Método de pagamento"].lower() == "boleto":
			conciliation = creditCardAndBillet(row["Valor bruto da parcela"],row["% Comissão"],row["Comissão ML por parcela"])
	    
	    elif row["Método de pagamento"].lower() == "estorno":
		    conciliation = reversal(row["Valor bruto do pedido"],row["% Comissão"],row["Valor líquido da parcela"])
		    
	    elif row["Método de pagamento"].lower() == "transferência":
		    row["Comissão ML por parcela "] = row["Valor da antecipação"]
		    row["Valor bruto da parcela"] = row["Valor líquido da parcela"]
		    
		    conciliation = transference(row["Valor da antecipação"])
	    
	    if conciliation != None:
		    row["Conciliação*"] = conciliation
	    
	    return row
Função que trata dos casos específicos da linha que é usada como parâmetro, de acordo com o "Método de Pagamento" a conciliação será tratada com uma função diferente, a função retorna a linha de entrada com o acréscimo da coluna de conciliação.

    def processRows(spreadsheet):
    
	    processedDataFrame = pd.DataFrame()
	    for index,row in spreadsheet.iterrows():
	    
		    treatedRow = specificCases(row)
		    print(treatedRow[["Data da transação","ID do pedido Seller","Método de pagamento","Comissão ML por parcela","Valor bruto da parcela","% Comissão","Conciliação*"]])
		    print('------------')
		    
		    processedDataFrame = processedDataFrame.append(treatedRow)
	    
	    return processedDataFrame
Função para acessar cada registro da base de dados, chamar a função que define a conciliação e em seguida imprimir na tela o registro somente com as colunas exigidas na regra de negócio, além disso um novo DataFrame com a coluna "Conciliação*" é criado para depois ser analisado.

    if __name__ == '__main__':
	    spreadsheet = loadSpreadSheet('planilha_de_repasse.xlsx')
	    newSpreadSheet = processRows(spreadsheet)
	    processInfos(newSpreadSheet)
Função principal, no primeiro comando irá carregar os dados da planilha, em sequência será rodado o comando para processar as linhas e retornar um novo DataFrame com a coluna "Conciliação*", por ultimo será rodado o comando para exibir informações a respeito dos dados analisados.

### seleniumExtraction

    from dotenv import load_dotenv
	from os import environ
    from selenium.webdriver import Chrome
    import time
A biblioteca dotenv será usada para gerenciar as variáveis de ambiente, a biblioteca os será usado para acessas as variáveis de ambiente, a biblioteca selenium será o core do algoritmo controlando toda a automação, a biblioteca time será usado para controlar o tempo entre execução de comandos.

    load_dotenv('assets/.env_selenium')
    webdriverPath = environ.get('WEBDRIVER')
    webdriver = Chrome(webdriverPath)
As variáveis globais basicamente irão carregar as variáveis de ambiente e fazer a instância do webdriver do Chrome.

    def acessPage(path):
	    webdriver.get(path)
Função para fazer acesso a página passada como parâmetro, apesar de parecer desnecessário é importante para manter o código mais legível.

    def setForms(formCriteria):
	     for key in formCriteria:
		   webdriver.find_element_by_id(key).send_keys(formCriteria[key])
Função para preencher formulários por id, recebe como parâmetro um dicionário com a seguinte estrutura: `{ID_DO_CAMPO:VALOR_A_SER_ENVIADO,...}`

    def arrayCheckClick(array,criteria):
    
        for item in array:
	        try:
		        if item.text == criteria:
			       time.sleep(1)
			        item.click()
        
	        except:
		        continue
Função para verificar diversos botões em uma lista e clicar nele caso seu valor de texto seja satisfeito pelo parâmetro "criteria".

    def removeDuplicateDays(array):
    
	    monthWeeks = False
	    previousValue = 0
	    outputArray = []
	    
	    for item in array:
		    
		    if int(item.text) < previousValue and monthWeeks:
			    break
		    
		    if int(item.text) > 1 and monthWeeks == False:
			    pass
		    
		    else:
			   previousValue = int(item.text)
			   monthWeeks = True
			   outputArray.append(item)
	    
	    return outputArray
Essa função possui uma tarefa bem específica que é remover valores duplicados nos botões para selecionar os dias do mês no componente de calendário do portal que é acessado, evitando inconsistências, principalmente quando for ser selecionado valores como "31" e "1".

    def setCalendar(calendarCriteria):
    
	    iFrameLocation = webdriver.find_element_by_id("main").find_element_by_class_name("container-fluid")
	    time.sleep(3)
		webdriver.switch_to.frame(iFrameLocation.find_element_by_tag_name("iframe"))
	    
	    calendarInput = webdriver.find_element_by_class_name("emulated-calendar__component")
	    calendarInput.click()
	    webdriver.find_element_by_class_name("react-calendar__navigation__label").click()
	    webdriver.find_element_by_class_name("react-calendar__navigation__label").click()
	    
	    yearButtons = webdriver.find_elements_by_class_name("react-calendar__decade-view__years__year")
	    arrayCheckClick(yearButtons,calendarCriteria["year"])
	    
	    monthButtons = webdriver.find_elements_by_class_name("react-calendar__year-view__months__month")
	    arrayCheckClick(monthButtons,calendarCriteria["month"])
	    
	    daysButtons = webdriver.find_elements_by_class_name("react-calendar__month-view__days__day")
		daysButtons = removeDuplicateDays(daysButtons)
	    arrayCheckClick(daysButtons,calendarCriteria["begin"])
	    arrayCheckClick(daysButtons,calendarCriteria["end"])
	    
	    exportExcel = webdriver.find_element_by_class_name("MuiButton-outlined")
	    exportExcel.click()
	    
	    time.sleep(2)
	    closeModal = webdriver.find_element_by_class_name("jss79").find_element_by_tag_name("button")
	    closeModal.click()
Essa função será encarregada de manipular o componente de calendário do portal, selecionando o ano,mês e dias em que será realizado a consulta e em sequência exportando os dados atráves do botão de exportação.Essa função recebe um dicíonario como parâmetro com os valores que irá usar no componente de calendário, o dicíonario possui a seguinte estrutura:`{"year":ano,"month":mês,"begin":primeiro dia,"end":ultimo dia}`

    def clickButton(tag_id):
	    webdriver.find_element_by_id(tag_id).click()
Função para clicar em botão, orientado por id.

    if __name__ == '__main__':
    
	    acessPage(environ.get("LOGIN_URL"))
	    
	    setForms({
		    "username":environ.get("EMAIL"),
		    "password":environ.get("PASSWORD")
	    })
	    
	    clickButton("kc-login")
	    acessPage(environ.get("ORDER_URL"))
	    setCalendar({
		    "year":"2018",
		    "month":"janeiro",
		    "begin":"1",
		    "end":"31"
		})
		webdriver.close()
A função principal executará primeiro o serviço para acessar a pagina de login, em sequência irá preencher o formulário da pagina de acordo com os parâmetros passados e clicará no botão de login e acessará a pagina de pedidos, em sequência executará a função para manipular o componente de calendário e exportar os dados, por ultimo irá fechar o webdriver.
